from recipes.models import (Ingredient, Tag, Recipe)
from rest_framework import serializers
from rest_framework.fields import SerializerMethodField
from users.models import User


# момент с аутентификацией решаем с помощью библиотеки djoser.

# djoser генерирует новые эндпоинты:
# /users/
# /users/me/
# /users/set_password/
# /tokin/login/
# /token/logout/

# для обработки этих эндпоинтов djoser по умолчанию использует
# свои собственные сериализаторы и вьюсеты. Если не переопределять сериализаторы, то
# будут по умолчанию применены сериализаторы из библиотеки djoser,
# созданные для сериализации базовой модели User.
# В нашем случае это не подходит, так как у нас используется не базовая модель User.
# Мы создавали собственную кастомную модель User на основе AbstractUser и
# поэтому и сериализаторы для этой модели прописываем самостоятельно.

# для нашей кастомной модели напишем следующие сериализаторы:

# Для обработки эндпоинта /users/ пишем 2 разных сериализатора -
# для чтения (получить список пользователей)
# и для записи(создать нового пользователя)

# Для обработки эндпоинта /users/me/ также пишем свой сериализатор.

# Остальные сериализаторы для обработки эндпоинтов /users/set_password/,
# /token/login/, /token/logout/ мы не пишем - используем их по умолчанию из библиотеки djoser.

# После создания сериализаторов указываем их в settings.py в настройках для Djoser.


# 1-ый сериализатор - для обработки запроса по эндпоинту /users/ -
# для чтения, т.е для получения списка пользователей.
# указываем модель, для которой пишем сериализатор и поля указываем явно.
class ReadUserSerializer(serializers.ModelSerializer):
    """[GET] Сериализатор для модели пользователя(только для чтения)."""

    # для поля is_subscribed указываем типом поля сериализатор SerializerMethodField,
    # так как это поле новое - его нет у модели User, но мы должны получить его на выходе
    # то есть, должна быть информация о подписках
    is_subscribed = serializers.SerializerMethodField()

    def get_is_subscribed(self, obj):
        pass

    class Meta:
        model = User
        fields = (
            'id',
            'email',
            'username',
            'first_name',
            'last_name',
            'password',
            'is_subscribed'
        )


class CreateUserSerializer(serializers.ModelSerializer):
    """
    [POST] Сериализатор для модели пользователя(для записи).
    Создание нового пользователя.
    """
    class Meta:
        model = User
        fields = (
            'email',
            'username',
            'first_name',
            'last_name',
            'password'
        )


# ГОТОВО
# создаем сериализатор для модели Ingredient
# эта модель простая, без связей.
# Сериализатор для нее тоже будет простым.
# В классе Meta указываем модель, для которой будет создан сериализатор
# и ЯВНО указываем поля модели, для которых необходима сериализация.
# Так как для модели Ingredient в апи-документации указан один тип запроса
# - GET, то в конструктор сериализатора для модели ингредиента
# поступает экземпляр модели Ingredient или queryset.
# Соответственно будет запущен именно процесс сериализации -
# прямое преобразование сложных данных (экземпляра модели или queryset)
# в простые типы данных Python и их дальнейшее преобразование в JSON-формат
class IngredientSerializer(serializers.ModelSerializer):
    """[GET]Сериализатор для модели ингредиентов."""
    class Meta:
        model = Ingredient
        fields = ('name', 'measurement_unit')


# ГОТОВО
# создаем сериализатор для модели Tag
# Это тожем простая модель, без связей.
# сериализатор для нее тоже простой.
# В классе Meta указываем модель, для которой будет создан сериализатор
# и ЯВНО перечисляем поля, для которых необходима сериализация.
# Так как для модели Tag в апи-документации указан только GET-запрос,
# то в конструктор сериализатора для модели тега
#  поступает экземпляр модели Tag.
# Соответственно будет запущен именно процесс сериализации -
# прямое преобразование сложных данных (экземпляра модели или queryset)
#  в простые типы данных Python и их дальнейшее преобразование в JSON-формат
class TagSerializer(serializers.ModelSerializer):
    """[GET]Сериализатор для модели тегов."""
    class Meta:
        model = Tag
        fields = ('id', 'name', 'color', 'slug')


class ReadRecipeSerializer(serializers.ModelSerializer):
    """[GET]Сериализатор для модели рецептов(только для чтения)."""
    # Этот сериализатор нужно прорабатывать более детально,
    # так как модель рецептов - сложная, со связями.
    # Для этого сериализатора нужно переопределить некоторые поля

    # 1. Модель Recipe связана с моделью User ч/з поле author(ForeignKey).
    # Для поля ForeignKey по умолчанию в сериализаторе будет тип поля
    # PrimaryKeyRelatedField -
    # т.е при GET-запросе рецепта будет получен id автора
    # это не информативно, нам необходимо получить строковое представление.
    # поэтому нам необходимо переопределить тип этого поля
    # Для этого сначала необходимо написать сериализатор для модели User(для чтения)
    # и применить его в качестве типа поля для author в нашем,
    # родительском сериализаторе.
    # То есть, теперь это поле будет возвращать объекты модели User,
    #  сериализованные в ReadUserSerializer.

    # 2. Модель Recipe связана с моделью Tag ч/з поле tags(ManyToManyField).
    # Если мы не переопределим тип этого поля в сериализаторе,
    # то запрашивая рецепт, мы также получим список id тегов
    # а не список самих тегов. Это не информативно.
    # Нужно переопределить тип этого поля.
    # Для этого используем созданный ранее сериализатор для модели Tag.
    # Применяем его в качестве типа поля tags и теперь
    # это поле будет возвращать объекты модели Tag,
    # сериализованные в TagSerializer - то есть, эти данные вернутся в виде JSON.

    # 3. Модель Recipe связана с моделью Ingredient ч/з поле ingredients(ManyToManyField).
    # Если мы не переопределим тип этого поля в сериализаторе,
    # то запрашивая рецепт, мы также получим список id ингредиентов
    # а не список самих ингредиентов. Необходимо переопределить тип поля.
    # Согласно макетам на фронте при запросе рецепта по его id
    # помимо всех прочих полей должен вернуться список ингредиентов
    # (именно ингредиентов, а не id ингредиентов) с указанием их кол-ва.
    # то есть, для этого поля необходимо произвести доп.вычисления,
    # то есть применить свой код для этого поля, модифицировать его.
    # Для этих целей используем SerializerMethodField в качестве типа поля
    # ingredients и далее выполняем вычисления для этого поля

    # 4. Для полей is_favorite и is_in_shopping_cart потребуется применить
    # SerializerMethodField. Этот тип поля применяют,
    # когда во время сериализации определенного поля требуется запустить
    #  какой-то свой код для того, чтобы получить значение этого поля.
    # Также часто при работе с апи требуется в ответе вернуть те поля,
    # которых нет в сериализуемой модели(как раз этих двух полей нет в модели Recipe).
    # То есть, с помощью SerializerMethodField можно модифицировать существующее поле
    # (например произвести какие-то вычисления с ним)
    # или создать новое поле(наш случай с этими 2 полями).
    # при запросе рецепта по этим двум полям должно вернуться булево значение
    # предварительно импортируем этот тип поля из rest-framework.fields.
    # Когда полю присвоен тип SerializerMethodField,
    # то DRF вызывает метод с именем def get <имя этого поля>


    # ИТОГ
    # для 3-ех полей сериализатора ReadRecipeSerializer
    # мы используем SerializerMethodField:
    # для поля ingredients -
    # для того, чтобы модифицировать это поле
    # для полей in_favorite, is_in_shopping_cart -
    #  для того, чтобы создать новые поля, которых нет в модели

    author = ReadUserSerializer(read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    ingredients = SerializerMethodField()
    is_favorite = SerializerMethodField()
    is_in_shopping_cart = SerializerMethodField()

    def get_ingredients(self, obj):
        """Выполняет вычисление кол-ва ингредиентов."""


    def get_is_favorite(self, obj):
        """Проверяет, добавил ли пользователь рецепт в избранное."""
        pass

    def get_is_in_shopping_cart(self, obj):
        """Проверяет, добавил ли пользователь рецепт в список покупок."""
        pass

    class Meta:
        # укажем модель
        model = Recipe
        # укажем поля, для которых необходима сериализация
        # часть этих полей выше будем переопределять
        fields = (
            'id',
            'tags',
            'author',
            'ingredients',
            'is_favorite',
            'is_in_shopping_cart',
            'name',
            'image',
            'text',
            'cooking_time'
        )


# class CreateRecipeSerializer(serializers.ModelSerializer):
#     """Сериализатор для модели рецептов(для записи)."""
#     author = serializers.StringRelatedField()

#     class Meta:
#         model = Recipe
#         fields = (
#             'author',
#             'tags',
#             'ingredients',
#             'name',
#             'image',
#             'text',
#             'cooking_time'
#         )


# class RecipeIngredientSerializer(serializers.ModelSerializer):
#     """Сериализатор для модели ингредиентов в составе рецепта."""
#     class Meta:
#         model = RecipeIngredient
#         fields = ('recipe', 'ingredient', 'amount')


# class FavoriteSerializer(serializers.ModelSerializer):
#     """Сериализатор для модели избранных рецептов."""
#     class Meta:
#         model = Favorite
#         fields = ('user', 'recipe')


# class ShoppingCartSerializer(serializers.ModelSerializer):
#     """Сериализатор для модели списка покупок."""
#     class Meta:
#         model = ShoppingCart
#         fields = ('user', 'recipe', 'add_date')
